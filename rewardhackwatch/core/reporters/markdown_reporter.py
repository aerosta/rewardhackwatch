"""Generate Markdown reports from analysis results."""

from datetime import datetime
from pathlib import Path
from typing import Any


class MarkdownReporter:
    """Generate Markdown analysis reports."""

    def __init__(self, include_toc: bool = True):
        self.include_toc = include_toc

    def generate(self, results: dict[str, Any]) -> str:
        """Generate Markdown report."""
        score = results.get("score", 0)
        risk_level = results.get("risk_level", "unknown").upper()
        detections = results.get("detections", [])

        toc = self._generate_toc() if self.include_toc else ""

        return f"""# RewardHackWatch Analysis Report

{toc}

## Summary

| Metric | Value |
|--------|-------|
| **Risk Score** | {score:.1%} |
| **Risk Level** | {risk_level} |
| **Detections** | {len(detections)} |
| **Generated** | {datetime.now().strftime("%Y-%m-%d %H:%M:%S")} |

## Risk Assessment

{self._risk_badge(score)} **{risk_level}**

{self._risk_description(score)}

## Detections

{self._render_detections(detections)}

## Recommendations

{self._generate_recommendations(results)}

---

*Generated by RewardHackWatch v0.1.0*
"""

    def _generate_toc(self) -> str:
        """Generate table of contents."""
        return """## Table of Contents

- [Summary](#summary)
- [Risk Assessment](#risk-assessment)
- [Detections](#detections)
- [Recommendations](#recommendations)
"""

    def _risk_badge(self, score: float) -> str:
        """Get emoji badge for risk level."""
        if score >= 0.8:
            return "ðŸ”´"
        elif score >= 0.6:
            return "ðŸŸ "
        elif score >= 0.4:
            return "ðŸŸ¡"
        elif score >= 0.2:
            return "ðŸŸ¢"
        return "âšª"

    def _risk_description(self, score: float) -> str:
        """Get description for risk level."""
        if score >= 0.8:
            return "**Critical risk detected.** Immediate review required. This trajectory exhibits strong indicators of reward hacking that may generalize to misalignment."
        elif score >= 0.6:
            return "**High risk detected.** Review recommended. Multiple concerning patterns identified."
        elif score >= 0.4:
            return "**Medium risk.** Some potentially suspicious patterns found. Consider investigation."
        elif score >= 0.2:
            return "**Low risk.** Minor indicators detected. Likely false positives."
        return "**No significant risk detected.** Trajectory appears clean."

    def _render_detections(self, detections: list[dict[str, Any]]) -> str:
        """Render detections as Markdown."""
        if not detections:
            return "No detections found.\n"

        lines = []
        for i, d in enumerate(detections, 1):
            pattern = d.get("pattern", d.get("pattern_name", "Unknown"))
            desc = d.get("description", "No description")
            location = d.get("location", "Unknown")
            confidence = d.get("confidence", 0)

            lines.append(f"""### Detection {i}: {pattern}

- **Description:** {desc}
- **Location:** `{location}`
- **Confidence:** {confidence:.0%}
""")

        return "\n".join(lines)

    def _generate_recommendations(self, results: dict[str, Any]) -> str:
        """Generate recommendations based on results."""
        score = results.get("score", 0)
        results.get("detections", [])

        if score >= 0.6:
            return """1. **Immediate Review:** This trajectory should be manually reviewed by a safety engineer.
2. **Pattern Analysis:** Examine the detected patterns for potential reward hacking behavior.
3. **Training Data:** Consider excluding this trajectory from training data.
4. **Model Audit:** If this pattern is recurring, consider a broader model audit."""

        elif score >= 0.4:
            return """1. **Review Recommended:** Consider manual review of flagged patterns.
2. **Monitor:** Track if similar patterns appear in other trajectories.
3. **Document:** Log findings for future reference."""

        else:
            return """No immediate action required. Continue monitoring."""

    def save(self, results: dict[str, Any], path: str):
        """Save Markdown report to file."""
        Path(path).write_text(self.generate(results))
